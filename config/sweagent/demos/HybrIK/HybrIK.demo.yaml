history:
  - role: assistant
    content: |-
      We will first create the final score file using the provided command
      ```
      create_final_score
      ```
    agent: main
    tool_calls:
    message_type: action
  - role: assistant
    content: |-
      The file was created successfully, we will now open it and start going over all the ablations in side A and side B.
      ```
      open final_score.jsonl
      ```
    agent: main
    tool_calls:
    message_type: action
  - role: assistant
    content: |-
      Let's go over all ablations in side A and side B to determine the matches based on the criteria provided.Side A:1. HybrIK Variant Comparison: This ablation replaces Adaptive HybrIK mechanism with several variants. In side B,  the ablation "Robustness of HybrIK to noise" deals with the adaptive HybrIK, it does replace it with one variant (GT joints) that matches side A variant (Naive HybrIK (using original parent joints)). Therefore, there is a match.
      ```
      edit 1:1
      {"name_in_A": "HybrIK Variant Comparison", "name_in_B": "Robustness of HybrIK to noise"}
      end_of_edit
      ```
    agent: main
    tool_calls:
    message_type: action
  - role: assistant
    content: |-
      Great, the file has been updated, we will move to the next ablation in side A.Shape Parameter Study: This ablation replaces SMPL shape parameter prediction with different methods. In side B, "Effect of shape parameters (β)" replaces shape parameters with ground-truth and zero β, which does not align with the replacement criteria. Therefore, no match.
      ```
      edit 2:2
      {"name_in_A": "Shape Parameter Study", "name_in_B": null}
      end_of_edit
      ```
    agent: main
    tool_calls:
    message_type: action
  - role: assistant
    content: |-
      Great, let's move to the next one in side A.Twist angle prediction: This ablation replaces the twist angle prediction network with different methods. In side B, "Analysis of the twist rotation" again focuses on twist angles with one replacement (zero twist angles) that matches. Therefore, we have a match here.
      ```
      edit 3:3
      {"name_in_A": "Twist Angle Prediction", "name_in_B": "Analysis of the twist rotation"}
      end_of_edit
      ```
    agent: main
    tool_calls:
    message_type: action
  - role: assistant
    content: |-
      Great, we will continue with the next one in side A.3D Keypoint Estimation Study: This ablation replaces the 3D keypoint estimation component with various alternatives. None of the ablations in side B address this component, so no match.
      ```
      edit 4:4
      {"name_in_A": "3D Keypoint Estimation Study", "name_in_B": null}
      end_of_edit
      ```
    agent: main
    tool_calls:
    message_type: action
  - role: assistant
    content: |-
      Great, Let's continue with the next one in side A.Twist-Swing Ablation: This ablation replaces the twist-and-swing decomposition with other methods. In side B, "Analysis of the twist rotation" is the closest one, though it focuses on twist angles specifically. Therefore, no match.
      ```
      edit 5:5
      {"name_in_A": "Twist-Swing Ablation", "name_in_B": null}
      end_of_edit
      ```
    agent: main
    tool_calls:
    message_type: action
  - role: assistant
    content: |-
      We have finished with all the ablations in side A. Now we will move to discuss the ablations in side B.Analysis of the twist rotation: was matched to "Twist angle prediction" from side A.So we can move on to the next one:Effect of shape parameters (β): There is no matching ablation in side A, the closes one is "Shape Parameter Study", but the replacements do not align.
      ```
      edit 6:6
      {"name_in_A": null, "name_in_B": "Effect of shape parameters (β)"}
      end_of_edit
      ```
    agent: main
    tool_calls:
    message_type: action
  - role: assistant
    content: |-
      We will move on to the next one in side B.Error correction capability of HybrIK: There is no matching ablation in side A, as none of the ablations in side A address error correction on the predicted pose.
      ```
      edit 7:7
      {"name_in_A": null, "name_in_B": "Error correction capability of HybrIK"}
      end_of_edit
      ```
    agent: main
    tool_calls:
    message_type: action
  - role: assistant
    content: |-
      Great let's move to the last one in side B, and by this we can conclude.Robustness of HybrIK to noise: was matched to "HybrIK Variant Comparison" from side A.So we have finished to go over all ablations in both sides, we can submit the score.
      ```
      submit
      ```
    agent: main
    tool_calls:
    message_type: action
replay_config:
  env:
    deployment:
      image: ablations-bench:judge
      port:
      docker_args:
        - -u
        - root
      startup_timeout: 180.0
      pull: missing
      remove_images: false
      python_standalone_dir:
      platform:
      type: docker
    repo:
      repo_name: repo
      base_commit: HEAD
      type: preexisting
    post_startup_commands: []
    post_startup_command_timeout: 500
    name: main
  agent:
    name: HybrIK
    templates:
      system_template: |-
        SETTING: You are an autonomous computer science researcher, and you're working directly in the command line of a linux container with a special interface.

        You are given a matching task between two sets of ablations: those presented in a research paper and those suggested in an ablation plan, but you do not know which set corresponds to the paper and which corresponds to the plan.
        A match means: The experiment described by ablation in side A is allowed or included as a possible option within ablation in side B (and vice versa).

        The special interface consists of a file editor that shows you {{WINDOW}} lines of a file at a time.
        In addition to typical bash commands, you can also use the following commands to help you navigate and edit files.

        COMMANDS:
        {{command_docs}}

        Please note that THE EDIT COMMAND REQUIRES PROPER INDENTATION.
        If you'd like to add the line '        print(x)' you must fully write that out, with all those spaces before the code! Indentation is important and code that is not indented correctly will fail and require fixing before it can be run.

        RESPONSE FORMAT:
        Your shell prompt is formatted as follows:
        (Open file: <path>)
        (Current directory: <cwd>)
        bash-$

        You need to format your output using two fields; discussion and command.
        Your output should always include _one_ discussion and _one_ command field EXACTLY as in the following example:
        DISCUSSION
        First I'll start by using ls to see what files are in the current directory. Then maybe we can look at some relevant files to see what they look like.
        ```
        ls -a
        ```

        You should only include a *SINGLE* command in the command section and then wait for a response from the shell before continuing with more discussion and commands. Everything you include in the DISCUSSION section will be saved for future reference.
        If you'd like to issue two commands at once, PLEASE DO NOT DO THAT! Please instead first submit just the first command, and then after receiving a response you'll be able to issue the second command.
        You're free to use any other bash commands you want (e.g. find, grep, cat, ls, cd) in addition to the special commands listed above.
        However, the environment does NOT support interactive session commands (e.g. python, vim), so please do not invoke them.
      instance_template: |-
        You are in an empty repository root directory `/repo`.
        We're currently want to review an ablation studies plan for the research paper {{paper_title}}. Here's the research abstract:
        ABSTRACT:
        {{abstract}}

        INSTRUCTIONS:
        Below, you will find the ablations performed in the paper and the suggested ablation plan.
        We do not provide any information which ablations belong to which source, so you need to carefully analyze each ablation in both paper and plan and determine if there is a match.
        Your task is to find a match between ablations in side A and ablations in side B, and vice versa.

        A match is considered valid only if all of the following are true:

        1. The `ablated_part` (i.e., the component or mechanism being ablated) must refer to the same component.

        2. The `action` in one ablation must be explicitly allowed by an ablation in the other side.

        3. If the action is REPLACE or ADD, the `replacement` content must have at least one valid option match.

        Examples:

        - REMOVE X → REPLACE X with [remove, Y]                MATCH
        - REPLACE X with Y → REMOVE X                          NO MATCH
        - REMOVE X → REMOVE X                                  MATCH
        - REPLAC X with [Y, Z] → REPLACE X with [Z, W]         MATCH
        - ADD Y to X → ADD  [Y, Z] to X                        MATCH
        - REPLACE (X+Y) with [X, Y, Z] → [REMOVE X, REMOVE Y]  MATCH

        Be conservative: if it is unclear whether one ablation allows the other ablation, do NOT match.

        The match can contain multiple ablations from either side, as long as the match meets the criteria above.
        For example, if an ablation in side A is split into two ablations in side B, but both of them together meet the matching criteria, then it is still considered a valid match.

        What You Need to Do:

        Create the file `/repo/final_score.jsonl` using the command `create_final_score` and then fill in the following fields for each entry:
        ```
        {"name_in_A": [ name of the ablation in side A OR a list of ablation names in side A OR null if there is no matching ablation for the ablation in side B ], "name_in_B": [ name of the matching ablation from side B OR a list of ablation names in side B OR null if there is no matching ablation for the ablation in side A ]}
        ```

        GENERAL IMPORTANT TIPS:

        1. The file should be initialized using the command `create_final_score`, after that you just need to edit it and fill in the the `name_in_B` or `name_in_A` (where applicable) field.

        2. The `name_in_A` and `name_in_B` should match exactly to the ablation names in side A and side B, respectively.

        3. You must go over ALL the ablations in side A and all ablations in side B, _each one of them should be in your prediction_.

        4. It is OK if one ablation from side A is split into multiple ablations in side B, or merged several side A ablations into one — as long as the matching criteria (per ablation in side A) are met, the match is still valid. This holds to the other direction as well (side B to side A).

        5. Please note that all information is in the following text and not in any file or directories in the environment, so you should base your decision only using the information below.

        6. Any operations on the environment besides creating the `/repo/final_score.jsonl` file and editing it are not necessary.


        STRATEGY:

        1. First call the `create_final_score` command to create the file.

        2. Then, for each ablation in side A, you should decide based on the criteria above if there is a valid match in side B, and vice versa.

        3. After that, you should have the information to fill in the `name_in_B` / `name_in_A` fields for each ablation in side A and side B, respectively. If the ablation is considered a match to one (or more) of the ablations in the other side, you should fill the appropriate ablation(s) in `name_in_B` / `name_in_A`, otherwise it should remain null.

        4. Submit your final score using the `submit` command.

        PLEASE NOTE THAT THE SUBMISSION FILE NEEDS TO BE INITIALIZED USING THE `create_final_score` COMMAND
        When you are done, run the `submit` command to confirm.
        You have access to the terminal session, so take your time and be precise.

        Here are the ablations in side A and side B:

        <ablations_in_A>
        {{side_A}}
        </ablations_in_A>

        <ablations_in_B>
        {{side_B}}
        </ablations_in_B>

        **Remember to include all the ablations in side A and side B in your predictions!**

        (Open file: {{open_file}})
        (Current directory: {{working_dir}})
        bash-$
      next_step_template: |-
        {{observation}}
        (Open file: {{open_file}})
        (Current directory: {{working_dir}})
        bash-$
      next_step_truncated_observation_template: 'Observation: {{observation}}<response clipped><NOTE>Observations should not exceeded {{max_observation_length}} characters. {{elided_chars}} characters were elided. Please try a different command that produces less output or use head/tail/grep/redirect the output to a file. Do not use interactive pagers.</NOTE>'
      max_observation_length: 100000
      next_step_no_output_template: |-
        Your command ran successfully and did not produce any output.
        (Open file: {{open_file}})
        (Current directory: {{working_dir}})
        bash-$
      strategy_template:
      demonstration_template: |
        Here is a demonstration of how to correctly accomplish this task.
        It is included to show you how to correctly use the interface.
        You do not need to follow exactly what is done in the demonstration.
        --- DEMONSTRATION ---
        {{demonstration}}
        --- END OF DEMONSTRATION ---
      demonstrations: []
      put_demos_in_history: true
      shell_check_error_template: |-
        Your bash command contained syntax errors and was NOT executed. Please fix the syntax errors and try again. This can be the result of not adhering to the syntax for multi-line commands. Here is the output of `bash -n`:
        {{bash_stdout}}
        {{bash_stderr}}
      command_cancelled_timeout_template: The command '{{command}}' was cancelled because it took more than {{timeout}} seconds. Please try a different command that completes more quickly.
    tools:
      filter:
        blocklist_error_template: Operation '{{action}}' is not supported by this environment.
        blocklist:
          - vim
          - vi
          - emacs
          - nano
          - nohup
          - gdb
          - less
          - tail -f
          - python -m venv
          - make
        blocklist_standalone:
          - python
          - python3
          - ipython
          - bash
          - sh
          - /usr/bin/bash
          - /usr/bin/bash
          - nohup
          - vi
          - vim
          - emacs
          - nano
          - su
        block_unless_regex:
          radare2: \b(?:radare2)\b.*\s+-c\s+.*
          r2: \b(?:radare2)\b.*\s+-c\s+.*
      bundles:
        - path: ../SWE-agent/tools/registry
          hidden_tools: []
        - path: ../SWE-agent/tools/defaults
          hidden_tools: []
        - path: ../SWE-agent/tools/edit_linting
          hidden_tools: []
        - path: ../SWE-agent/tools/ablation_submit
          hidden_tools: []
        - path: ../SWE-agent/tools/ablation_review_suggestion
          hidden_tools: []
      env_variables:
        WINDOW: 100
        OVERLAP: 2
      registry_variables:
        ABLATIONS_PLAN_PATH: /repo/final_score.jsonl
      submit_command: submit
      parse_function:
        error_message: |
          Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
          Please make sure your output precisely matches the following format:
          DISCUSSION
          Discuss here with yourself about what your planning and what you're going to do in this step.

          ```
          command(s) that you're going to run
          ```
        type: thought_action
      enable_bash_tool: true
      format_error_template: |
        Your output was not formatted correctly. You must always include one discussion and one command as part of your response. Make sure you do not have multiple discussion/command tags.
        Please make sure your output precisely matches the following format:
        DISCUSSION
        Discuss here with yourself about what your planning and what you're going to do in this step.

        ```
        command(s) that you're going to run
        ```
      command_docs: |+
        bash:
          docstring: runs the given command directly in bash
          signature: <command>
          arguments:
            - command (string) [required]: The bash command to execute.

        goto:
          docstring: moves the window to show <line_number>
          signature: goto <line_number>
          arguments:
            - line_number (integer) [required]: the line number to move the window to

        open:
          docstring: opens the file at the given path in the editor. If line_number is provided, the window will be move to include that line
          signature: open "<path>" [<line_number>]
          arguments:
            - path (string) [required]: the path to the file to open
            - line_number (integer) [optional]: the line number to move the window to (if not provided, the window will start at the top of the file)

        create:
          docstring: creates and opens a new file with the given name
          signature: create <filename>
          arguments:
            - filename (string) [required]: the name of the file to create

        scroll_up:
          docstring: moves the window up 100 lines
          signature: scroll_up

        scroll_down:
          docstring: moves the window down 100 lines
          signature: scroll_down

        edit:
          docstring: Replaces lines <start_line> through <end_line> (inclusive) with the given text in the open file. All of the <replacement text> will be entered, so make sure your indentation is formatted properly.
        Please note that THIS COMMAND REQUIRES PROPER INDENTATION. If you'd like to add the line '        print(x)' you must fully write that out, with all those spaces before the code!

          signature: edit <start_line>:<end_line>
        <replacement_text>
        end_of_edit

          arguments:
            - start_line (integer) [required]: the line number to start the edit at
            - end_line (integer) [required]: the line number to end the edit at (inclusive)
            - replacement_text (string) [required]: the text to replace the current selection with

        submit:
          docstring: submits the current ablation plan
          signature: submit

        create_final_score:
          docstring: create the /repo/final_score.jsonl file for submission
          signature: create_final_score

      multi_line_command_endings:
        edit: end_of_edit
      submit_command_end_name:
      reset_commands: []
      execution_timeout: 600
      install_timeout: 300
      total_execution_timeout: 3600
      max_consecutive_execution_timeouts: 3
    history_processors:
      - n: 5
        polling: 1
        always_remove_output_for_tags:
          - remove_output
        always_keep_output_for_tags:
          - keep_output
        type: last_n_observations
    model:
      name: human_thought
      per_instance_cost_limit: 3.0
      total_cost_limit: 0.0
      per_instance_call_limit: 0
      temperature: 0.0
      top_p: 1.0
      api_base:
      api_version:
      api_key:
      stop: []
      completion_kwargs: {}
      convert_system_to_user: false
      retry:
        retries: 20
        min_wait: 10.0
        max_wait: 120.0
      delay: 0.0
      fallbacks: []
      choose_api_key_by_thread: true
      max_input_tokens:
    max_requeries: 3
    action_sampler:
    type: default
  problem_statement:
    text: '[{"name": "Analysis of the twist rotation", "ablated_part": "Twist angles in the twist-and-swing decomposition", "action": "REPLACE", "replacement": ["Random values in [-\u03c0, \u03c0]", "Zero twist angles", "Network-estimated twist angles"], "metrics": ["Mean error of reconstructed 24 SMPL joints", "Mean error of 14 LSP joints", "Mean error of body mesh", "Mean error of twist angle"]}, {"name": "Robustness of HybrIK to noise", "ablated_part": "Comparison between Naive HybrIK to Adaptive HybrIK with different input joints", "action": "REPLACE", "replacement": ["GT joints", "10mm noise", "20mm noise", "30mm noise"], "metrics": ["MPJPE"]}, {"name": "Effect of shape parameters (\u03b2)", "ablated_part": "Shape parameters (\u03b2) in SMPL model", "action": "REPLACE", "replacement": ["Ground-truth \u03b2", "Zero \u03b2"], "metrics": ["MPJPE", "PVE"]}, {"name": "Error correction capability of HybrIK", "ablated_part": "Apply different algorithms on the predicted pose and compare it to HybrIK", "action": "REPLACE", "replacement": ["SMPLify"], "metrics": ["MPJPE"]}]'
    extra_fields:
      abstract: |
        Model-based 3D pose and shape estimation methods reconstruct a full 3D mesh for the human body by estimating several parameters. However, learning the abstract parameters is a highly non-linear process and suffers from image-model misalignment, leading to mediocre model performance. In contrast, 3D keypoint estimation methods combine deep CNN network with the volumetric representation to achieve pixel-level localization accuracy but may predict unrealistic body structure. In this paper, we address the above issues by bridging the gap between body mesh estimation and 3D keypoint estimation. We propose a novel hybrid inverse kinematics solution (HybrIK). HybrIK directly transforms accurate 3D joints to relative body-part rotations for 3D body mesh reconstruction, via the twist-and-swing decomposition. The swing rotation is analytically solved with 3D joints, and the twist rotation is derived from the visual cues through the neural network. We show that HybrIK preserves both the accuracy of 3D pose and the realistic body structure of the parametric human model, leading to a pixel-aligned 3D body mesh and a more accurate 3D pose than the pure 3D keypoint estimation methods. Without bells and whistles, the proposed method surpasses the state-of-the-art methods by a large margin on various 3D human pose and shape benchmarks. As an illustrative example, HybrIK outperforms all the previous methods by \textbf{13.2} mm MPJPE and \textbf{21.9} mm PVE on 3DPW dataset. Our code is available at \href{https://github.com/Jeff-sjtu/HybrIK}{https://github.com/Jeff-sjtu/HybrIK}.
      paper_title: 'HybrIK: A Hybrid Analytical-Neural Inverse Kinematics Solution for 3D Human Pose and Shape Estimation'
      side_A: |-
        {"name": "HybrIK Variant Comparison", "ablated_part": "Adaptive HybrIK mechanism", "action": "REPLACE", "replacement": ["Naive HybrIK (using original parent joints)", "Adaptive HybrIK (using reconstructed parent joints)", "Iterative global optimization (non-differentiable baseline)"], "metrics": ["MPJPE (mm)", "PVE (mm)", "Error accumulation along kinematic tree"]}
        {"name": "Shape Parameter Study", "ablated_part": "SMPL shape parameter prediction", "action": "REPLACE", "replacement": ["Mean shape parameters", "PCA-based shape space reduction", "Direct vertex offset prediction"], "metrics": ["MPJPE (mm)", "PVE (mm)", "Shape error metrics"]}
        {"name": "Twist Angle Prediction", "ablated_part": "Twist angle prediction network", "action": "REPLACE", "replacement": ["Fixed twist angles (0 degrees)", "Constrained range predictions", "Multi-head prediction network"], "metrics": ["MPJPE (mm)", "PVE (mm)", "Physical plausibility score"]}
        {"name": "3D Keypoint Estimation Study", "ablated_part": "3D keypoint estimation component", "action": "REPLACE", "replacement": ["Direct regression without volumetric representation", "Different heatmap resolutions", "Alternative backbone architectures"], "metrics": ["MPJPE (mm)", "PVE (mm)", "Per-joint accuracy"]}
        {"name": "Twist-Swing Ablation", "ablated_part": "Twist-and-swing decomposition of rotations", "action": "REPLACE", "replacement": ["Direct rotation regression (3-DoF) as in previous works", "Only swing component (2-DoF)", "Only twist component (1-DoF)"], "metrics": ["MPJPE (mm)", "PVE (mm)", "Reconstruction error"]}
      side_B: |-
        {"name": "Analysis of the twist rotation", "ablated_part": "Twist angles in the twist-and-swing decomposition", "action": "REPLACE", "replacement": ["Random values in [-\u03c0, \u03c0]", "Zero twist angles", "Network-estimated twist angles"], "metrics": ["Mean error of reconstructed 24 SMPL joints", "Mean error of 14 LSP joints", "Mean error of body mesh", "Mean error of twist angle"]}
        {"name": "Effect of shape parameters (\u03b2)", "ablated_part": "Shape parameters (\u03b2) in SMPL model", "action": "REPLACE", "replacement": ["Ground-truth \u03b2", "Zero \u03b2"], "metrics": ["MPJPE", "PVE"]}
        {"name": "Error correction capability of HybrIK", "ablated_part": "Apply different algorithms on the predicted pose and compare it to HybrIK", "action": "REPLACE", "replacement": ["SMPLify"], "metrics": ["MPJPE"]}
        {"name": "Robustness of HybrIK to noise", "ablated_part": "Comparison between Naive HybrIK to Adaptive HybrIK with different input joints", "action": "REPLACE", "replacement": ["GT joints", "10mm noise", "20mm noise", "30mm noise"], "metrics": ["MPJPE"]}
    type: text
    id: HybrIK
  output_dir: DEFAULT
  actions:
    open_pr: false
    pr_config:
      skip_if_commits_reference_issue: true
    apply_patch_locally: false
  env_var_path:
